---
title: "`r params$savingName`"
author: ""
date: "`r Sys.Date()`"
output:
  html_document:
    toc: false
    toc_float: false
params:
  classVariable: NULL
  idColumn: NULL
  numTrees: NULL
  mtrysvm: NULL
  mtrycentroids: NULL
  diagnosticChangeProbability: NULL
  nCores: NULL
  seed: NULL
  svmData: NULL
  svmDataAll: NULL
  #svmSolution: NULL
  importanceSVMControl2Case: NULL
  importanceSVMCase2Control: NULL
  svm_lasso_after_cf: NULL
  svm_lasso_after_model: NULL
  svm_lasso_before_cf: NULL
  svm_lasso_before_model: NULL
  svm_RF_after_cf: NULL
  svm_RF_after_model: NULL
  svm_RF_before_cf: NULL
  svm_RF_before_model: NULL
  svmTotalWilcoxControls: NULL
  svmTotalOddsControls: NULL
  svmTotalWilcoxCases: NULL
  svmTotalOddsCases: NULL
  clinicDataSVM: NULL
  originalDiagnosis: NULL
  categoricActivePredictors: NULL
  numericActivePredictors: NULL
  svm_lasso_before_ci: NULL
  svm_RF_before_ci: NULL
  #enrich_case2control_changed: NULL
  #enrich_case2control_maintained: NULL
  #elbow_case2control: NULL
  #enrich_control2case_changed: NULL
  #enrich_control2case_maintained: NULL
  #elbow_control2case: NULL
  lambdas: NULL
  C: NULL
  gamma: NULL
  svm_svmLinear_after_cf: NULL
  svm_svmLinear_after_model: NULL
  svm_svmLinear_before_cf: NULL
  svm_svmLinear_before_model: NULL
  svm_svmLinear_before_ci: NULL
  svm_svmRadial_after_cf: NULL
  svm_svmRadial_after_model: NULL
  svm_svmRadial_before_cf: NULL
  svm_svmRadial_before_model: NULL
  svm_svmRadial_before_ci: NULL
  savingName: NULL
  partitionPercentage: NULL
  kernel: NULL
  enrichment: NULL
  absolutePath: NULL
  omicData: NULL
  #modelsControl2Case: NULL
  labelsControl2Case: NULL
  hcControl2Case: NULL
  xControl2Case: NULL
  clustersControl2Case: NULL
  dendControl2Case: NULL
  importancesControl2Case: NULL
  enrichmentsControl2Case: NULL
  cmControl2Case: NULL
  elbowsControl2Case: NULL
  #modelsCase2Control: NULL
  labelsCase2Control: NULL
  hcCase2Control: NULL
  xCase2Control: NULL
  clustersCase2Control: NULL
  dendCase2Control: NULL
  importancesCase2Control: NULL
  enrichmentsCase2Control: NULL
  cmCase2Control: NULL
  elbowsCase2Control: NULL
  omic: NULL
  genesCase2Control: NULL
  genesControl2Case: NULL
  domainTable: NULL
  outliersSolution: NULL
  thresholdControl: NULL
  thresholdCase: NULL
  mergeData: NULL
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE}
classVariable                <- params$classVariable
idColumn                     <- params$idColumn
numTrees                     <- params$numTrees
mtrysvm                      <- params$mtrysvm
mtrycentroids                <- params$mtrycentroids
diagnosticChangeProbability  <- params$diagnosticChangeProbability
nCores                       <- params$nCores
seed                         <- params$seed
svmData                      <- params$svmData
svmDataAll                   <- params$svmDataAll
importanceSVMControl2Case    <- params$importanceSVMControl2Case
importanceSVMCase2Control    <- params$importanceSVMCase2Control
svmTotalWilcoxControls       <- params$svmTotalWilcoxControls
svmTotalOddsControls         <- params$svmTotalOddsControls
svmTotalWilcoxCases          <- params$svmTotalWilcoxCases
svmTotalOddsCases            <- params$svmTotalOddsCases
clinicDataSVM                <- params$clinicDataSVM
originalDiagnosis            <- params$originalDiagnosis
categoricActivePredictors    <- params$categoricActivePredictors
numericActivePredictors      <- params$numericActivePredictors
lambdas                      <- params$lambdas
C                            <- params$C
gamma                        <- params$gamma
savingName                   <- params$savingName
partitionPercentage          <- params$partitionPercentage
kernel                       <- params$kernel
enrichment                   <- params$enrichment
absolutePath                 <- params$absolutePath
omicData                     <- params$omicData
labelsControl2Case           <- params$labelsControl2Case
hcControl2Case               <- params$hcControl2Case
xControl2Case                <- params$xControl2Case
clustersControl2Case         <- params$clustersControl2Case
dendControl2Case             <- params$dendControl2Case
importancesControl2Case      <- params$importancesControl2Case
enrichmentsControl2Case      <- params$enrichmentsControl2Case
cmControl2Case               <- params$cmControl2Case
elbowsControl2Case           <- params$elbowsControl2Case
labelsCase2Control           <- params$labelsCase2Control
hcCase2Control               <- params$hcCase2Control
xCase2Control                <- params$xCase2Control
clustersCase2Control         <- params$clustersCase2Control
dendCase2Control             <- params$dendCase2Control
importancesCase2Control      <- params$importancesCase2Control
enrichmentsCase2Control      <- params$enrichmentsCase2Control
cmCase2Control               <- params$cmCase2Control
elbowsCase2Control           <- params$elbowsCase2Control
omic                         <- params$omic
genesCase2Control            <- params$genesCase2Control
genesControl2Case            <- params$genesControl2Case
domainTable                  <- params$domainTable
outliersSolution             <- params$outliersSolution
thresholdControl             <- params$thresholdControl
thresholdCase                <- params$thresholdCase
mergeData                    <- params$mergeData
```

```{r, include=FALSE}
library(plotly)
library(lazyeval)
library(ggtext)
```

# MLASDO {.tabset}

```{r, echo = FALSE}
# percentage <- diagnosticChangeProbability * 100

N <- nrow(clinicDataSVM)

n_outliers <- sum(outliersSolution == 1) / N

percentage <- round(n_outliers * 100, 3)

gamma <- gamma
```

```{r, echo = FALSE}
summaryClinic <- clinicDataSVM
```


<!-- It has been decided to modify the top **`r percentage`%** from the total number of patients. -->

The MLASDO method works as follows:

1.  An SVM model is optimized searching through the following hyperparameters:

  - C: **`r C`**
  
  - Kernel: **`r kernel`**
  
  - gamma: **`r gamma`**

2.  Once the best hyperparameters are found, the misclassified samples during cross-validation are observed.

3.  From these selected samples those furthest from the hyperplane generated by the SVM are chosen.

4. **HERE I HAVE TO EXPLAIN THE METHOD TO SELECT THE OUTLIERS**

## Method results {.tabset}

In this section you will see: **1)** the number of final modified cases and controls; **2)** svm accuracy results for each hyperparameter combination; and **3)** the performance of linear and nonlinear models with the original data versus the data with the modified patients.

### 1. SVM accuracy

```{r, echo = FALSE}
C <- svmData$best_c

kernel <- svmData$best_kernel

gamma <- svmData$best_gamma

BalancedAccuracy <- round(svmData$best_balanced_acc,3)
```

The final hyperparameters of the SVM model are: C = **`r C`**, kernel = **`r kernel`** type and gamma = **`r gamma`**. The model has obtained a balanced accuracy of **`r BalancedAccuracy`**.

```{r, echo = FALSE, warning=FALSE, fig.width=10, fig.height=10}
svmDataAll_aux <- svmDataAll

svmDataAll_aux$Status <- originalDiagnosis[svmDataAll_aux$index]

ggplot(svmDataAll_aux, aes(x = c, y = mean_balanced_accuracy, color = kernel)) +
  geom_line(aes(group = kernel)) +  # Línea para cada kernel
  geom_point() +  # Puntos para cada valor
  scale_x_log10() +  # Escala logarítmica en el eje X
  facet_wrap(~ gamma, scales = "free_y") +  # Facetado por valores de Gamma
  labs(title = "Balanced Accuracy by C, Kernel and Gamma", 
       x = "C", 
       y = "Balanced Accuracy") +
  theme_minimal()
```



### 2. Outliers samples detected 

```{r, echo = FALSE}
original_Case_samples <- mergeData[mergeData[[classVariable]] == "Case", ]
original_Control_samples <- mergeData[mergeData[[classVariable]] == "Control", ]

# Combine data for plotting
plot_data_original <- rbind(
  data.frame(distance = original_Case_samples$distance, Group = "Case"),
  data.frame(distance = original_Control_samples$distance, Group = "Control")
)

# Plot the density distributions
ggplot(plot_data_original, aes(x = distance, fill = Group)) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Distribution of distances for cases and controls",
    x = "Distance",
    y = "Density"
  ) +
  theme_minimal() + 
  geom_vline(xintercept = thresholdCase, linetype = "dashed", color = "red") +
  geom_vline(xintercept = thresholdControl, linetype = "dashed", color = "blue")
```


### 3. Diagnostics distribution

```{r, include = FALSE}
originalDF <- data.frame(
  Case = sum(originalDiagnosis == "Case"),
  Control = sum(originalDiagnosis == "Control")
)

changedDF <- data.frame(
  Case = sum(clinicDataSVM[[classVariable]] == "Case"),
  Control = sum(clinicDataSVM[[classVariable]] == "Control"),
  Case2Control = sum(clinicDataSVM[[classVariable]] == "Case2Control"),
  Control2Case = sum(clinicDataSVM[[classVariable]] == "Control2Case")
)
```

```{r, include = FALSE}
originalBars <- plot_ly(originalDF, x = "CASE", y = ~Case, type = 'bar', name = 'Num Case', marker = list(color = "#EE3B3B"), hovertext = ~Case, hovertemplate = "Patients: %{y}<extra></extra>")

originalBars <- originalBars %>% add_trace(x = "CONTROL", y = ~Control, name = 'Num Control', marker = list(color = "#A2CD5A"), hovertext = ~Control, hovertemplate = "Patients: %{y}<extra></extra>")

originalBars <- originalBars %>% style(hoverinfo = 'none')

originalBars <- originalBars %>% layout(title = "Distribution of patient diagnoses", yaxis = list(title = "Number of patients (before detection) <br> <br>")) 

originalBars <- originalBars %>% layout(yaxis = list(range = c(0, ceiling(max(originalDF) / 10) * 10)))
```

```{r, include = FALSE}
changedBars <- plot_ly(changedDF, x = "CASE", y = ~Case, type = 'bar', name = 'Num Case', marker = list(color = "#EE3B3B"), hovertext = ~Case, hovertemplate = "Patients: %{y}<extra></extra>")

changedBars <- changedBars %>% add_trace(x = "CONTROL", y = ~Control, name = 'Num Control', marker = list(color = "#A2CD5A"), hovertext = ~Control, hovertemplate = "Patients: %{y}<extra></extra>")

changedBars <- changedBars %>% add_trace(x = "CASE2CONTROL", y = ~Case2Control, name = 'Num Case2Control', marker = list(color = "#B23AEE"), hovertext = ~Case2Control, hovertemplate = "Patients: %{y}<extra></extra>")

changedBars <- changedBars %>% add_trace(x = "CONTROL2CASE", y = ~Control2Case, name = 'Num Control2Case', marker = list(color = "#00E5EE"), hovertext = ~Control2Case, hovertemplate = "Patients: %{y}<extra></extra>")

changedBars <- changedBars %>% style(hoverinfo = 'none')

changedBars <- changedBars %>% layout(title = "Distribution of patient diagnoses", yaxis = list(title = "Number of patients (after detection) <br> <br>"))  

changedBars <- changedBars  %>% layout(yaxis = list(range = c(0, ceiling(max(originalDF) / 10) * 10)))
```

```{r, include = FALSE}
distributionDashboard <- subplot(originalBars, changedBars, nrows = 1, margin = 0.1, shareX = FALSE, shareY = FALSE, titleX = TRUE, titleY = TRUE)  

distributionDashboard <- distributionDashboard %>%  layout(title = "Distribution of patient diagnoses", showlegend = FALSE)
```

```{r, echo = FALSE, fig.height=5}
distributionDashboard
```

### 4. Models performance

```{r, echo = FALSE}
lambdas <- params$lambdas

min.lambda <- min(lambdas)
max.lambda <- max(lambdas)

n_lambdas <- length(lambdas)

C <- params$C

min.c <- min(C)
max.c <- max(C)

n_c <- length(C)
```

```{r, echo = FALSE}
trainN <- partitionPercentage * 100

testN <- (1 - partitionPercentage)* 100
```

The results below summarize the performance of lineal models (lasso and svmLinear) and non lineal models (Random Forest and svmRadial) predicting **`r classVariable`** in the original data and after the status changes.

Training was performed using 10-fold cross-validation (which confidence interval will be reported) using **`r trainN`%** of the omic dataset as training set and leaving the rest for test.

The Random Forest model uses: numTrees = **`r numTrees`** and mtry = **`r mtrysvm`**.

The Lasso model uses **`r n_lambdas`** number of lambdas from **`r min.lambda`** to **`r max.lambda`**.

The SVM models uses **`r n_c`** number of costs from **`r min.c`** to **`r max.c`**.

```{r, echo = FALSE}
# Assuming the confusion matrices are already created and contain Balanced Accuracy
# Extract Balanced Accuracy from confusion matrices
rf_before_balanced_accuracy <- round(params$svm_RF_before_cf$byClass['Balanced Accuracy'], 3)
rf_after_balanced_accuracy <- round(params$svm_RF_after_cf$byClass['Balanced Accuracy'], 3)

lasso_before_balanced_accuracy <- round(params$svm_lasso_before_cf$byClass['Balanced Accuracy'], 3)
lasso_after_balanced_accuracy <- round(params$svm_lasso_after_cf$byClass['Balanced Accuracy'], 3)

calculate_balanced_accuracy <- function(conf_matrix) {
  TP <- conf_matrix["Case", "Case"]
  FN <- conf_matrix["Control", "Case"]
  FP <- conf_matrix["Case", "Control"]
  TN <- conf_matrix["Control", "Control"]
  
  sensitivity <- TP / (TP + FN)
  specificity <- TN / (TN + FP)
  
  balanced_accuracy <- (sensitivity + specificity) / 2
  return(round(balanced_accuracy, 3))
}

# Calcular Balanced Accuracy para cada caso
svmLinear_before_balanced_accuracy <- calculate_balanced_accuracy(params$svm_svmLinear_before_cf)
svmRadial_before_balanced_accuracy <- calculate_balanced_accuracy(params$svm_svmRadial_before_cf)

svmLinear_after_balanced_accuracy <- calculate_balanced_accuracy(params$svm_svmLinear_after_cf)
svmRadial_after_balanced_accuracy <- calculate_balanced_accuracy(params$svm_svmRadial_after_cf)


# svmLinear_before_balanced_accuracy <- round(params$svm_svmLinear_before_cf$byClass['Balanced Accuracy'], 3)
# svmLinear_after_balanced_accuracy <- round(params$svm_svmLinear_after_cf$byClass['Balanced Accuracy'], 3)
# 
# svmRadial_before_balanced_accuracy <- round(params$svm_svmRadial_before_cf$byClass['Balanced Accuracy'], 3)
# svmRadial_after_balanced_accuracy <- round(params$svm_svmRadial_after_cf$byClass['Balanced Accuracy'], 3)


# Extraer intervalos de confianza (CI) para Balanced Accuracy y redondear a 3 decimales
rf_before_ci <- round(params$svm_RF_before_ci, 3)
lasso_before_ci <- round(params$svm_lasso_before_ci, 3)
svmLinear_before_ci <- round(params$svm_svmLinear_before_ci, 3)
svmRadial_before_ci <- round(params$svm_svmRadial_before_ci, 3)

# Crear la tabla con las columnas intercambiadas y redondeos aplicados
balanced_accuracy_table <- data.frame(
  Model = c("Random Forest", "Lasso", "svmLinear", "svmRadial"),
  Train_CI = c(paste0("(", rf_before_ci[1], ", ", rf_before_ci[2], ")"),
                paste0("(", lasso_before_ci[1], ", ", lasso_before_ci[2], ")"),
                paste0("(", svmLinear_before_ci[1], ", ", svmLinear_before_ci[2], ")"),
                paste0("(", svmRadial_before_ci[1], ", ", svmRadial_before_ci[2], ")")),
  Original_Test = c(rf_before_balanced_accuracy, lasso_before_balanced_accuracy, svmLinear_before_balanced_accuracy, svmRadial_before_balanced_accuracy),
  Changed_Test = c(rf_after_balanced_accuracy, lasso_after_balanced_accuracy, svmLinear_after_balanced_accuracy, svmRadial_after_balanced_accuracy)
)

# Imprimir tabla en formato markdown
knitr::kable(balanced_accuracy_table, caption = "Balanced Accuracy before and after changes with Confidence Intervals")
```


## Covariables analysis {.tabset}

In this section you will see: **1)** the statistical results to analyze how the modified patients differ from the rest of their class
and **2)** the local explainability where the most outlier patients detected can be individually examined;

<!-- ; and **3)** a summary table of the previous statistical results. -->

<!-- Modal Personalizado -->
<div id="customModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:50%; max-height:80%; padding:20px; background:white; border:1px solid #ccc; z-index:10000;">
  <div id="modalContent" style="max-height:60vh; overflow-y:auto;"></div>
  <button onclick="$('#customModal').hide()">Close</button>
</div>

```{r, echo = FALSE, warning = FALSE}
# Paso 1: Calcular la posición x correspondiente al 5% del número de filas
# N <- nrow(clinicDataSVM)

x_pos_num <- round(n_outliers * N)  # Añadimos 1 para alinearnos con la indexación de Plotly

df <- svmData$selected_samples

df_sorted <- df[order(df$distance, decreasing = TRUE), ]

clinic_ordered <- clinicDataSVM[
  clinicDataSVM[[classVariable]] %in% c("Case2Control", "Control2Case"),
]
```


```{r, echo = FALSE, warning = FALSE}
if(nrow(clinic_ordered) > 0){

  map_values_with_domain_table <- function(df, domain_table) {
    # Crear una copia del dataframe para modificaciones
    df_mapped <- df
    
    # Iterar sobre las filas de domain_table
    for (i in seq_len(nrow(domain_table))) {
      
      row <- domain_table[i, ]
      feature <- as.character(row$Feature)
      value_condition <- as.character(row$Value)
      sign <- as.character(row$Sign)
      group <- as.character(row$Group)
      
      # Seleccionar el subconjunto según el grupo
      subset_condition <- df[[classVariable]] == group
      
      # Determinar si `value_condition` es una condición lógica o un valor específico
      if (grepl("^==", value_condition)) {
        # Condición específica de igualdad (== algo)
        target_value <- as.numeric(sub("==", "", value_condition))
        condition_met <- df[[feature]] == target_value
      } else if (grepl("^[><=]", value_condition)) {
        # Otras condiciones lógicas que requieren eval(parse(...))
        
          numeric_column <- as.numeric(as.character(df[[feature]]))
          condition_met <- with(df, eval(parse(text = paste0("numeric_column ", value_condition))))
      } else {
        # Valor específico sin condición, comparamos directamente
        condition_met <- df[[feature]] == value_condition
      }
      
      df_mapped[[feature]] <- ifelse(
        subset_condition & condition_met,
        paste0(df[[feature]], " ", sign),
        df_mapped[[feature]]
      )
    }
    
    return(df_mapped)
  }
  
  # Aplicar la función a clinic_ordered
  clinic_ordered_mapped <- map_values_with_domain_table(clinic_ordered, domainTable)
  
  # 2. Crear las columnas clinicSupport y clinicSupportRatio
  num_domain_features <- length(unique(domainTable$Feature))
  
  clinic_ordered_mapped$clinicSupport <- apply(clinic_ordered_mapped, 1, function(row) {
    sum(sapply(row, function(cell) {
      sum(grepl("\\+", unlist(strsplit(as.character(cell), " "))))
    }))
  })
  
  clinic_ordered_mapped$clinicSupportRatio <- paste0(clinic_ordered_mapped$clinicSupport, " / ", num_domain_features)
  
  clinic_ordered_mapped$AgreeRNAClinic <- ifelse(clinic_ordered_mapped$clinicSupport > 0, "Yes", "No")
  
  # 4. Seleccionar las columnas en el orden deseado
  domainTableFeatures <- unique(domainTable$Feature)
  
  clinicDomainTable <- clinic_ordered_mapped %>% dplyr::select(
    clinicSupport, 
    clinicSupportRatio, 
    all_of(classVariable),
    AgreeRNAClinic, 
    all_of(idColumn), 
    all_of(setdiff(names(clinic_ordered_mapped), c(idColumn, classVariable)))
  )
  
  
  get_thresholds <- function(feature, group_value, sign) {
    thresholds <- domainTable %>%
      filter(Feature == feature & Group == group_value & Sign == sign) %>%
      dplyr::select(Value) %>%
      pull()
    return(as.character(thresholds))
  }
  
  clinicDomainTable$PositiveColumns <- rep("", nrow(clinicDomainTable))
  
  clinicDomainTable$PositiveColumns <- apply(clinic_ordered_mapped, 1, function(row) {
    group_value <- row[[classVariable]]
  
    round_value <- function(value) {
      value_clean <- gsub(" [\\+\\-]", "", value)
      value_num <- as.numeric(value_clean)
      if (!is.na(value_num)) {
        return(as.character(round(value_num, 3)))
      } else {
        return(value_clean)
      }
    }
  
    positive_feature_thresholds <- list()
    negative_feature_thresholds <- list()
  
    for (feature in domainTableFeatures) {
      cell <- as.character(row[[feature]])
      value <- round_value(cell)
  
      if (grepl("\\+", cell)) {
        thresholds <- get_thresholds(feature, group_value, "+")
        if (feature %in% names(positive_feature_thresholds)) {
          positive_feature_thresholds[[feature]]$thresholds <- unique(c(positive_feature_thresholds[[feature]]$thresholds, thresholds))
        } else {
          positive_feature_thresholds[[feature]] <- list(value = value, thresholds = thresholds)
        }
      }
  
      if (grepl("\\-", cell)) {
        thresholds <- get_thresholds(feature, group_value, "+")
        if (feature %in% names(negative_feature_thresholds)) {
          negative_feature_thresholds[[feature]]$thresholds <- unique(c(negative_feature_thresholds[[feature]]$thresholds, thresholds))
        } else {
          negative_feature_thresholds[[feature]] <- list(value = value, thresholds = thresholds)
        }
      }
    }
  
    # Construir las cadenas HTML
    positive_vars <- sapply(names(positive_feature_thresholds), function(feature) {
      value <- positive_feature_thresholds[[feature]]$value
      thresholds <- positive_feature_thresholds[[feature]]$thresholds
      thresholds_str <- paste(unique(thresholds), collapse = ",")
      paste0(feature, ": ", value, " (", thresholds_str, ")<br>")
    })
  
    negative_vars <- sapply(names(negative_feature_thresholds), function(feature) {
      value <- negative_feature_thresholds[[feature]]$value
      thresholds <- negative_feature_thresholds[[feature]]$thresholds
      thresholds_str <- paste(unique(thresholds), collapse = ",")
      paste0(feature, ": ", value, " (", thresholds_str, ")<br>")
    })
  
    result <- paste(
      if (length(positive_vars) > 0) {
        paste("<b>Covariates that support the change:</b><br>", paste(positive_vars, collapse = ""))
      } else {
        NULL
      },
      if (length(negative_vars) > 0) {
        paste("<b>Covariates that do not support the change:</b><br>", paste(negative_vars, collapse = ""))
      } else {
        NULL
      },
      sep = "<br><br>"
    )
  
    # Asegurarse de que siempre se devuelva algo
    if (length(result) == 0 || is.null(result) || result == "") {
      return("")  # Devolver una cadena vacía si no hay resultado
    } else {
      return(result)
    }
  })

}
```


### 1. Global explainability {.tabset}

For the categorical covariables the following tests have been performed:

-   **Odds Ratio:** The test is considered significant if its confidence interval does not cross 1.

-   **chi-square test:** The test is considered significant if it has a p-value less than 0.05.

-   **fisher test:** The test is considered significant if it has a p-value less than 0.05.

If one of the previous tests is significant it will be shown. Fisher test will be applied when there is any value less than 10 in the contingency table.

For the numerical covariables the following tests have been performed:

-   **Mann-Whitney test:** The test is considered significant if it has a p-value less than 0.05.

#### 1.1. Control2Case global explainability {.tabset}

Results of the significant tests obtained from analyzing controls that have been modified into cases compared to the rest of the controls.

##### 1.1.1. Categorical predictors

```{r, echo = FALSE}
totalOddsControls <- svmTotalOddsControls

totalOddsControls <- totalOddsControls[!is.na(totalOddsControls$Fisher_chi.square), ]

totalOddsControls <- totalOddsControls %>%
  filter(as.numeric(Fisher_chi.square) < 0.05)
```



```{r, echo = FALSE}
if(nrow(totalOddsControls) > 0){
  
  evaluate_condition <- function(value_expression, feature_value) {
    value_expression <- trimws(value_expression)  # Eliminar espacios extra
    return(value_expression == feature_value)
  }
  
  # Renombrar las columnas en totalOddsControls
  names(totalOddsControls)[names(totalOddsControls) == "SumCCFirst"] <- "Control2CaseValue"
  names(totalOddsControls)[names(totalOddsControls) == "SumCCSecond"] <- "Control2CaseRest"
  names(totalOddsControls)[names(totalOddsControls) == "SumCMFirst"] <- "ControlValue"
  names(totalOddsControls)[names(totalOddsControls) == "SumCMSecond"] <- "ControlRest"
  
  totalOddsControls <- totalOddsControls %>%
    rowwise() %>%
    mutate(
      OddRatio = round(OddRatio, 3),
      Fisher_chi.square = formatC(Fisher_chi.square, format = "e", digits = 3),
      # Buscar el valor de "RELATIVE_TO" en domainTable
      RELATIVE_TO = case_when(
        any(domainTable$Group == "Control2Case" &
            domainTable$Feature == Feature &
            sapply(domainTable$Value, evaluate_condition, FeatureValue) &
            domainTable$Sign == "+") ~ "Case",
        any(domainTable$Group == "Control2Case" &
            domainTable$Feature == Feature &
            sapply(domainTable$Value, evaluate_condition, FeatureValue) &
            domainTable$Sign == "-") ~ "Control",
        TRUE ~ "Indeterminated"
      )
    ) %>%
    ungroup()
  
  # Reordenar las columnas para que "RELATIVE_TO" esté entre "FeatureValue" y "FeatureRestValues"
  totalOddsControls <- totalOddsControls %>%
    dplyr::select(OddRatio, Fisher_chi.square, Feature, FeatureValue, RELATIVE_TO, FeatureRestValues, 
           Control2CaseValue, Control2CaseRest, ControlValue, ControlRest)
}
```

```{r, echo = FALSE}
if(nrow(totalOddsControls) > 0){

  generate_html_text <- function(df) {
    df %>%
      rowwise() %>%
      mutate(
        description = paste0(
          "<p><strong>Covariate:</strong> ", Feature, "</p>",
          "<p>For the covariate <strong>", Feature, "</strong> we evaluated the change in AHC when the level of this covariate is <strong>", FeatureValue, 
          "</strong> compared to the remaining levels (<strong>", FeatureRestValues, "</strong>). In this case, the <strong>OddRatio</strong> value is <strong>", OddRatio, 
          ifelse(OddRatio < 1, 
                 "</strong>, less than 1, suggesting that the probability of the event (AHC) is significantly lower in the group {", 
                 "</strong>, greater than 1, indicating that the AHC event is more likely in the group {"), 
          FeatureValue, "} compared to the group {", FeatureRestValues, "}.</p>"
        ),

        # Condición para validar coherencia con explicación detallada y caso "Indeterminated"
        coherence_check = case_when(
          OddRatio > 1 & RELATIVE_TO == "Case" ~ paste(
            "The result is <strong>consistent</strong> with domain expert expectations because patients with ", Feature, " = ", FeatureValue, 
            " are more likely to belong to the Case group while ", Feature, " ≠ ", FeatureValue, " are more likely to belong to the Control group."
          ),
          OddRatio < 1 & RELATIVE_TO == "Control" ~ paste(
            "The result is <strong>consistent</strong> with domain expert expectations because patients with ", Feature, " = ", FeatureValue, 
            " are more likely to belong to the Control group while ", Feature, " ≠ ", FeatureValue, " are more likely to belong to the Case group."
          ),
          RELATIVE_TO == "Indeterminated" ~ "The result cannot be evaluated for consistency because the RELATIVE_TO value is <strong>Indeterminated</strong>.",
          TRUE ~ paste(
            "The result is <strong>inconsistent</strong> with domain expert expectations. The OddRatio does not align with the expected relationship based on RELATIVE_TO. The OddRatio is",
            OddRatio, "with RELATIVE_TO as", RELATIVE_TO, "."
          )
        )
      ) %>%
      mutate(
        # Eliminar el salto de línea antes de la evaluación del p-valor
        description = paste0(description, " ", coherence_check, 
                             " This observation is supported by a p-value of <strong>", Fisher_chi.square, "</strong>.</p>")
      ) %>%
      pull(description) %>%
      paste(collapse = "\n")
  }

  # Generate the HTML
  html_text_control2case <- generate_html_text(totalOddsControls)

} else {
  html_text_control2case <- NULL
}

```

`r html_text_control2case`

```{r, echo = FALSE}
DT::datatable(
  totalOddsControls[2,] %>%
    dplyr::rename(
      "OR" = OddRatio,
      "p-value" = Fisher_chi.square,
      "Covariate" = Feature,
      "Value" = FeatureValue,
      "Relative to" = RELATIVE_TO,
      "Other Values" = FeatureRestValues,
      "AHC Value" = Control2CaseValue,
      "AHC Other Value" = Control2CaseRest,
      "HC Value" = ControlValue,
      "HC Other Value" = ControlRest
    ) %>%
    dplyr::select(
      "OR", "p-value", "Covariate", "Value", "Relative to", "Other Values",
      "AHC Value", "HC Value",
      "AHC Other Value", "HC Other Value"
    ),
  options = list(scrollX = TRUE),
  rownames = FALSE
)

```

##### 1.1.2. Numerical predictors

```{r, echo = FALSE, warning=FALSE}
totalWilcoxControls <- svmTotalWilcoxControls
```

```{r, echo = FALSE, warning=FALSE}
# Getting wilcox controls for every feature excepting those with all NA in one of the groups
totalWilcoxControls_test <- totalWilcoxControls %>%
  group_by(predictor) %>%
  mutate(
    wilcox_pvalue = ifelse(
      any(group == "Controls2Cases" & !is.na(value)) && any(group == "Controls" & !is.na(value)),
      wilcox.test(value ~ group)$p.value,
      NA
    )
  )

# Removing predictors without wilcox test
totalWilcoxControls_test <- totalWilcoxControls_test %>%
  filter(!is.na(wilcox_pvalue))

totalWilcoxControls_test <- totalWilcoxControls_test %>%
  filter(wilcox_pvalue <= 0.05)

# Ordering by wilcox test 
totalWilcoxControls_test <- totalWilcoxControls_test %>%
  arrange(wilcox_pvalue)
```

```{r, echo = FALSE}
filtered_domain <- domainTable %>% 
  filter(Group == "Case2Control" & Feature %in% totalWilcoxControls_test$predictor)

# Creamos una función auxiliar para realizar el cambio de nombre en `predictor`
update_predictor <- function(predictor_name) {
  # Seleccionamos las filas de `filtered_domain` que coincidan con el `predictor`
  matching_rows <- filtered_domain %>% filter(Feature == predictor_name)
  
  # Verificamos si hay alguna coincidencia en `domainTable`
  if (nrow(matching_rows) > 0) {
    # Seleccionamos la primera coincidencia con un ">" o ">="
    row_with_sign <- matching_rows %>% filter(grepl("^>=", Value) | grepl("^>", Value))
    
    if (nrow(row_with_sign) > 0) {
      # Asignamos el sufijo de acuerdo a "Sign"
      if (row_with_sign$Sign[1] == "+") {
        return(paste(predictor_name, "\n(Higher in controls)"))
      } else if (row_with_sign$Sign[1] == "-") {
        return(paste(predictor_name, "\n(Higher in cases)"))
      }
    }
  }
  
  # Si no hay coincidencias o no cumple con los criterios, se asigna "Indeterminated"
  return(paste(predictor_name, "(Indeterminated)"))
}

totalWilcoxControls_test <- totalWilcoxControls_test %>%
  mutate(predictor = sapply(predictor, update_predictor))

```


```{r, echo = FALSE, warning=FALSE}
predictors <- unique(totalWilcoxControls_test$predictor)

cel <- ceiling(length(predictors) / 3)

height <- cel * 6
```

```{r, echo = FALSE, warning=FALSE}
if (nrow(totalWilcoxControls_test) > 0){
  knitr::opts_chunk$set(fig.height = height)
} else {
  height = 1
}
```


```{r, fig.width=10, fig.height=height, warning=FALSE, echo = FALSE}
if (nrow(totalWilcoxControls_test) > 0){
  totalWilcoxControls_test$predictor <- factor(totalWilcoxControls_test$predictor, levels = unique(totalWilcoxControls_test$predictor))
  
  p <- ggboxplot(totalWilcoxControls_test, x = "group", y = "value",
                     color = "group", palette = "npg") + facet_wrap( ~ predictor, ncol = 3, scales = "free")
  
  my_comparisons <- list(c("Controls2Cases", "Controls"))
  p <- p + stat_compare_means(method = "wilcox.test", comparisons = my_comparisons, size = 5)
  
  p <- p + stat_summary(fun = mean, 
                        geom = "text", 
                        aes(label = paste(round(..y.., 4))), 
                        position = position_dodge(width = 0.50),
                        vjust = -1, 
                        size = 4,
                        color = "black")
  
  p <- p + theme(axis.text.x = element_text(size = 10),
                   strip.text.x = element_text(size = 8.5),
                   axis.title.y = element_text(size = 10),
                   strip.text = element_text(size = 10),
                  plot.title = element_text(size = 7)
  )
  
  p
}
```

```{r}
totalWilcoxControls_test <- totalWilcoxControls_test %>%
  mutate(group = ifelse(group == "Controls2Cases", "AHC", group))

totalWilcoxControls_test <- totalWilcoxControls_test %>%
  mutate(group = ifelse(group == "Controls", "HC", group))

totalWilcoxControls_test <- totalWilcoxControls_test %>%
  mutate(predictor = recode(predictor,
    "t_naive_cd4_cd8_t_memory_cd4 \n(Higher in controls)" = "CD4/CD8 naive T-cells\nand CD4 memory T-cells\n(Higher in HC)",
    "mds_updrs_part_i_summary_score \n(Higher in cases)" = "MDS UPDRS Part I\n(Higher in PD)",
    "neutrophils_mature \n(Higher in cases)" = "Mature Neutrophils\n(Higher in PD)",
    "monocytes_progenitor \n(Higher in controls)" = "Progenitor Monocytes\n(Higher in HC)",
    "mds_updrs_part_iii_summary_score \n(Higher in cases)" = "MDS UPDRS Part III\n(Higher in PD)"
  ))

```


```{r, fig.width=11, fig.height=4, warning=FALSE, echo = FALSE}
if (nrow(totalWilcoxControls_test) > 0) {

  p <- ggboxplot(totalWilcoxControls_test, x = "group", y = "value",
                 color = "group", palette = "npg") + 
      facet_wrap(~ predictor, ncol = 5, scales = "free")

  my_comparisons <- list(c("AHC", "HC"))

  p <- p + stat_compare_means(method = "wilcox.test", 
                              comparisons = my_comparisons, 
                              label = "p.signif", 
                              size = 5)

  p <- p + stat_summary(fun = mean, 
                        geom = "text", 
                        aes(label = paste(round(..y.., 4))), 
                        position = position_dodge(width = 0.50),
                        vjust = -1, 
                        size = 6, 
                        color = "black")

  p <- p + theme(axis.text.x = element_text(size = 20),
                 strip.text.x = element_text(size = 22),
                 axis.title.y = element_text(size = 22),
                 axis.title.x = element_text(size = 22),
                 legend.text = element_text(size = 15), 
                 legend.title = element_text(size = 15) 
  )
  
  p
}

```



The following table shows the clinical information of Control2Case patients.

```{r, echo = FALSE}
if (nrow(totalWilcoxControls_test) > 0) {
  clinicDomainTableControl2Case <- clinicDomainTable[clinicDomainTable[[classVariable]] == "Control2Case", ]
  
  datatable(
    clinicDomainTableControl2Case,
    class = 'cell-border stripe',
    options = list(
      scrollX = TRUE,
      columnDefs = list(
        list(visible = FALSE, targets = "PositiveColumns")
      ),
      rowCallback = JS(
        "function(row, data) {
          var positiveColumns = data[data.length - 1];
          $(row).on('click', function() {
            if (positiveColumns) {
              $('#modalContent').html('<h3>Covariates Details</h3>' + positiveColumns);  // Set the content with HTML formatting
              $('#customModal').show();  // Display the modal
            }
          });
        }"
      )
    ),
    escape = FALSE
  )
}


```



```{r, echo = FALSE}
if (nrow(totalWilcoxControls_test) > 0) {
  control2case_num_features <- unique(totalWilcoxControls_test$predictor)
  
  for(feature in control2case_num_features){
    
    clinic_ordered_mapped[[paste0(feature, "_test")]] <- ifelse(clinic_ordered[[classVariable]] == "Control2Case", 1, 0)
  
  }
}
```


#### 1.2. Case2Control global explainability {.tabset}

Results of the significant tests obtained from analyzing cases that have been modified into controls compared to the rest of the cases.

##### 1.2.1. Categorical predictors

```{r, echo = FALSE}
totalOddsCases <- svmTotalOddsCases

totalOddsCases <- totalOddsCases[!is.na(totalOddsCases$Fisher_chi.square), ]

totalOddsCases <- totalOddsCases %>%
  filter(as.numeric(Fisher_chi.square) < 0.05)
```

```{r, echo = FALSE}
if(nrow(totalOddsCases) > 0){
  
# Renombrar las columnas en totalOddsCases
names(totalOddsCases)[names(totalOddsCases) == "SumCCFirst"] <- "Case2ControlValue"
names(totalOddsCases)[names(totalOddsCases) == "SumCCSecond"] <- "Case2ControlRest"
names(totalOddsCases)[names(totalOddsCases) == "SumCMFirst"] <- "CaseValue"
names(totalOddsCases)[names(totalOddsCases) == "SumCMSecond"] <- "CaseRest"

# Añadir la columna "RELATIVE_TO" al dataframe totalOddsControls usando domainTable
totalOddsCases <- totalOddsCases %>%
  rowwise() %>%
  mutate(
    OddRatio = round(OddRatio, 3),
    Fisher_chi.square = formatC(Fisher_chi.square, format = "e", digits = 3),
    # Buscar el valor de "RELATIVE_TO" en domainTable
    RELATIVE_TO = case_when(
      any(domainTable$Group == "Case2Control" & 
          domainTable$Feature == Feature & 
          domainTable$Value == FeatureValue & 
          domainTable$Sign == "+") ~ "Control",
      any(domainTable$Group == "Case2Control" & 
          domainTable$Feature == Feature & 
          domainTable$Value == FeatureValue & 
          domainTable$Sign == "-") ~ "Case",
      TRUE ~ "Indeterminated"
    )
  ) %>%
  ungroup()  # Deshacemos el agrupamiento al final para evitar problemas en operaciones posteriores

# Reordenar las columnas para que "RELATIVE_TO" esté entre "FeatureValue" y "FeatureRestValues"
totalOddsCases <- totalOddsCases %>%
  dplyr::select(OddRatio, Fisher_chi.square, Feature, FeatureValue, RELATIVE_TO, FeatureRestValues, 
         Case2ControlValue, Case2ControlRest, CaseValue, CaseRest)

}
```

```{r, echo = FALSE}
if(nrow(totalOddsCases) > 0){

  generate_html_text <- function(df) {
    df %>%
      rowwise() %>%
      mutate(
        description = paste0(
          "<p><strong>Covariate:</strong> ", Feature, "</p>",
          "<p>For the covariate <strong>", Feature, "</strong> we evaluated the change in Case2Control when the value of this covariate is <strong>", FeatureValue, 
          "</strong> compared to the remaining values (<strong>", FeatureRestValues, "</strong>). In this case, the <strong>OddRatio</strong> value is <strong>", OddRatio, 
          ifelse(OddRatio < 1, 
                 "</strong>, less than 1, suggesting that the probability of the event (Case2Control) is significantly lower in the group {", 
                 "</strong>, greater than 1, indicating that the Case2Control event is more likely in the group {"), 
          FeatureValue, "} compared to the group {", FeatureRestValues, "}.<br>",
          "This observation is supported by a p-value of <strong>", Fisher_chi.square, "</strong>.<br>",
          "The value <strong>", FeatureValue, "</strong> is relative to <strong>", RELATIVE_TO, "</strong>.</p>"
        )
      ) %>%
      pull(description) %>%
      paste(collapse = "\n")
  }
  
  # Generate the HTML
  html_text_case2control <- generate_html_text(totalOddsCases)

} else {
  html_text_case2control <- ""
}
```

`r html_text_case2control`

```{r, echo = FALSE}
DT::datatable(
  totalOddsCases,
  options = list(scrollX = TRUE),
  rownames = FALSE
)

```

##### 1.2.2. Numerical predictors

```{r, echo = FALSE, warning=FALSE}
totalWilcoxCases <- svmTotalWilcoxCases
```

```{r, echo = FALSE, warning=FALSE}
# Getting wilcox controls for every feature excepting those with all NA in one of the groups
totalWilcoxCases_test <- totalWilcoxCases %>%
  group_by(predictor) %>%
  mutate(
    wilcox_pvalue = ifelse(
      any(group == "Cases2Controls" & !is.na(value)) && any(group == "Cases" & !is.na(value)),
      wilcox.test(value ~ group)$p.value,
      NA
    )
  )

# Removing predictors without wilcox test
totalWilcoxCases_test <- totalWilcoxCases_test %>%
  filter(!is.na(wilcox_pvalue))

totalWilcoxCases_test <- totalWilcoxCases_test %>%
  filter(wilcox_pvalue <= 0.05)

# Ordering by wilcox test 
totalWilcoxCases_test <- totalWilcoxCases_test %>%
  arrange(wilcox_pvalue)
```

```{r, echo = FALSE}
filtered_domain <- domainTable %>% 
  filter(Group == "Control2Case" & Feature %in% totalWilcoxCases_test$predictor)

# Creamos una función auxiliar para realizar el cambio de nombre en `predictor`
update_predictor <- function(predictor_name) {
  # Seleccionamos las filas de `filtered_domain` que coincidan con el `predictor`
  matching_rows <- filtered_domain %>% filter(Feature == predictor_name)
  
  # Verificamos si hay alguna coincidencia en `domainTable`
  if (nrow(matching_rows) > 0) {
    # Seleccionamos la primera coincidencia con un ">" o ">="
    row_with_sign <- matching_rows %>% filter(grepl("^>=", Value) | grepl("^>", Value))
    
    if (nrow(row_with_sign) > 0) {
      # Asignamos el sufijo de acuerdo a "Sign"
      if (row_with_sign$Sign[1] == "+") {
        return(paste(predictor_name, "(Higher in cases)"))
      } else if (row_with_sign$Sign[1] == "-") {
        return(paste(predictor_name, "(Higher in controls)"))
      }
    }
  }
  
  # Si no hay coincidencias o no cumple con los criterios, se asigna "Indeterminated"
  return(paste(predictor_name, "(Indeterminated)"))
}

totalWilcoxCases_test <- totalWilcoxCases_test %>%
  mutate(predictor = sapply(predictor, update_predictor))

```


```{r, echo = FALSE, warning=FALSE}
predictors <- unique(totalWilcoxCases_test$predictor)

cel <- ceiling(length(predictors) / 3)

height <- cel * 6
```

```{r, echo = FALSE, warning=FALSE}
if (nrow(totalWilcoxCases_test) > 0){
  knitr::opts_chunk$set(fig.height = height)
} else {
  height = 1
}
```

```{r, fig.width=10, fig.height=height, warning=FALSE, echo = FALSE}
if (nrow(totalWilcoxCases_test) > 0){
  totalWilcoxCases_test$predictor <- factor(totalWilcoxCases_test$predictor, levels = unique(totalWilcoxCases_test$predictor))
  
  p <- ggboxplot(totalWilcoxCases_test, x = "group", y = "value",
                     color = "group", palette = "npg") + facet_wrap( ~ predictor, ncol = 3, scales = "free")
  
  my_comparisons <- list(c("Cases2Controls", "Cases"))
  p <- p + stat_compare_means(method = "wilcox.test", comparisons = my_comparisons, size = 5)
  
  p <- p + stat_summary(fun = mean, 
                        geom = "text", 
                        aes(label = paste(round(..y.., 4))), 
                        position = position_dodge(width = 0.50),
                        vjust = -1, 
                        size = 4,
                        color = "black")
  
  p <- p + theme(axis.text.x = element_text(size = 10),
                   strip.text.x = element_text(size = 8.5),
                   axis.title.y = element_text(size = 10),
                   strip.text = element_text(size = 10),
                 plot.title = element_text(size = 7)
  )
  
  p
}
```

The following table shows the clinical information of Case2Control patients.

```{r, echo = FALSE}
if (nrow(totalWilcoxCases_test) > 0) {
  clinicDomainTableCase2Control<- clinicDomainTable[clinicDomainTable[[classVariable]] == "Case2Control", ]
  
  datatable(
    clinicDomainTableCase2Control,
    class = 'cell-border stripe',
    options = list(
      scrollX = TRUE,
      columnDefs = list(
        list(visible = FALSE, targets = "PositiveColumns")
      ),
      rowCallback = JS(
        "function(row, data) {
          var positiveColumns = data[data.length - 1];
          $(row).on('click', function() {
            if (positiveColumns) {
              $('#modalContent').html('<h3>Covariates Details</h3>' + positiveColumns);  // Set the content with HTML formatting
              $('#customModal').show();  // Display the modal
            }
          });
        }"
      )
    ),
    escape = FALSE
  )
}

```

```{r, echo = FALSE}
if (nrow(totalWilcoxCases_test) > 0) {
  case2Control_num_features <- unique(totalWilcoxCases_test$predictor)
  
  for(feature in case2Control_num_features){
    
    clinic_ordered_mapped[[paste0(feature, "_test")]] <- ifelse(clinic_ordered[[classVariable]] == "Case2Control", 1, 0)
    
  }
}
```

```{r, include=FALSE, echo = FALSE}
knitr::opts_chunk$set(fig.height = 7)
```

### 2. Local explainability

In the following plot all the misclassified samples are presented. The graph is divided at the point corresponding to the most outlier patients which in this case represent **`r percentage`%** of the total number of patients.

```{r, echo = FALSE}
# # Paso 1: Calcular la posición x correspondiente al 5% del número de filas
# N <- nrow(clinicDataSVM)
# x_pos_num <- round(0.05 * N)  # Añadimos 1 para alinearnos con la indexación de Plotly
# 
# df <- svmData$selected_samples
# 
# df_sorted <- df[order(df$Distance, decreasing = TRUE), ]

# Paso 2: Crear el gráfico de barras con Plotly y añadir la línea vertical
fig <- plot_ly(
  data = df_sorted,
  x = ~factor(index, levels = index),  # Asegura que el orden se preserve
  y = ~distance,
  type = 'bar'
) %>%
  layout(
    title = 'Misclassified samples by the SVM method',
    xaxis = list(title = 'Index', tickangle = -45),
    yaxis = list(title = 'Distance to the hyperplane'),
    margin = list(b = 100),
    shapes = list(
      list(
        type = "line",
        x0 = x_pos_num,
        x1 = x_pos_num,
        y0 = 0,
        y1 = 1,
        xref = "x",
        yref = "paper",
        line = list(color = "black", dash = "dash", width = 2)
      )
    )
  )

# Mostrar el gráfico
fig
```

In the following table the covariables of the most outlier patients (those who are on the left in the previous graph) are presented.

```{r, echo = FALSE, warning = FALSE}
# clinic_ordered <- clinicDataSVM[df_sorted[1:x_pos_num,]$Index, ]
 
nameDir <- paste(absolutePath, savingName, "data", sep = "/")
dir.create(nameDir)

namePath <- paste(nameDir, paste(savingName, "_modified_patients.rds", sep = ""), sep = "/")
   
# if (omic == ""){
  
  # DT::datatable(clinic_ordered, class = 'cell-border stripe', options = list(scrollX = TRUE))

  #saveRDS(clinic_ordered, namePath)

  # clinic_ordered_mapped <- clinic_ordered
# }
```

```{r, echo = FALSE, warning = FALSE}
# map_values_with_domain_table <- function(df, domain_table, class_variable) {
#   # Crear una copia del dataframe para modificaciones
#   df_mapped <- df
#   
#   # Iterar sobre las filas de domain_table
#   for (i in seq_len(nrow(domain_table))) {
#     
#     row <- domain_table[i, ]
#     feature <- as.character(row$Feature)
#     value_condition <- as.character(row$Value)
#     sign <- as.character(row$Sign)
#     group <- as.character(row$Group)
#     
#     # Seleccionar el subconjunto según el grupo
#     subset_condition <- df[[classVariable]] == group
#     
#     # Determinar si `value_condition` es una condición lógica o un valor específico
#     if (grepl("^==", value_condition)) {
#       # Condición específica de igualdad (== algo)
#       target_value <- as.numeric(sub("==", "", value_condition))
#       condition_met <- df[[feature]] == target_value
#     } else if (grepl("^[><=]", value_condition)) {
#       # Otras condiciones lógicas que requieren eval(parse(...))
#       condition_met <- with(df, eval(parse(text = paste0(feature, " ", value_condition))))
#     } else {
#       # Valor específico sin condición, comparamos directamente
#       condition_met <- df[[feature]] == value_condition
#     }
#     
#     df_mapped[[feature]] <- ifelse(
#       subset_condition & condition_met,
#       paste0(df[[feature]], " ", sign),
#       df_mapped[[feature]]
#     )
#   }
#   
#   return(df_mapped)
# }
# 
# # Aplicar la función a clinic_ordered
# clinic_ordered_mapped <- map_values_with_domain_table(clinic_ordered, domainTable, "Group")
# 
# # 2. Crear las columnas clinicSupport y clinicSupportRatio
# num_domain_features <- length(unique(domainTable$Feature))
# 
# clinic_ordered_mapped$clinicSupport <- apply(clinic_ordered_mapped, 1, function(row) {
#   sum(sapply(row, function(cell) {
#     sum(grepl("\\+", unlist(strsplit(as.character(cell), " "))))
#   }))
# })
# 
# clinic_ordered_mapped$clinicSupportRatio <- paste0(clinic_ordered_mapped$clinicSupport, " / ", num_domain_features)
# 
# clinic_ordered_mapped$AgreeRNAClinic <- ifelse(clinic_ordered_mapped$clinicSupport > 0, "Yes", "No")
# 
# # 4. Seleccionar las columnas en el orden deseado
# domainTableFeatures <- unique(domainTable$Feature)
# 
# clinicDomainTable <- clinic_ordered_mapped %>% dplyr::select(
#   clinicSupport, 
#   clinicSupportRatio, 
#   all_of(classVariable),
#   AgreeRNAClinic, 
#   all_of(idColumn), 
#   all_of(setdiff(names(clinic_ordered_mapped), c(idColumn, classVariable)))
# )
# 
# 
# get_threshold <- function(feature, group_value, sign) {
#   threshold <- domainTable %>%
#     filter(Feature == feature & Group == group_value & Sign == sign) %>%
#     dplyr::select(Value) %>%
#     pull()
#   return(as.character(threshold))
# }
# 
# clinicDomainTable$PositiveColumns <- apply(clinic_ordered_mapped, 1, function(row) {
#   group_value <- row[[classVariable]]  # Obtener el valor de la variable de clase para la fila actual
# 
#   # Función para redondear el valor a 3 decimales
#   round_value <- function(value) {
#     # Remover el signo y espacios del valor
#     value_clean <- gsub(" [\\+\\-]", "", value)
#     value_num <- as.numeric(value_clean)
#     if (!is.na(value_num)) {
#       return(as.character(round(value_num, 3)))
#     } else {
#       return(value_clean)
#     }
#   }
# 
#   # Variables con "+"
#   positive_vars <- Filter(Negate(is.null), sapply(domainTableFeatures, function(feature) {
#     cell <- as.character(row[[feature]])
#     if (grepl("\\+", cell)) {
#       threshold <- get_threshold(feature, group_value, "+")  # Filtrar por signo "+"
#       value <- round_value(cell)  # Redondear el valor a 3 decimales
#       paste(feature, ":", value, "(", threshold, ")")
#     } else {
#       NULL
#     }
#   }))
# 
#   # Variables con "-"
#   negative_vars <- Filter(Negate(is.null), sapply(domainTableFeatures, function(feature) {
#     cell <- as.character(row[[feature]])
#     if (grepl("\\-", cell)) {
#       threshold <- get_threshold(feature, group_value, "-")  # Filtrar por signo "-"
#       value <- round_value(cell)  # Redondear el valor a 3 decimales
#       paste(feature, ":", value, "(", threshold, ")")
#     } else {
#       NULL
#     }
#   }))
# 
#   # Combinar las variables en el orden deseado
#   paste(
#     if (length(positive_vars) > 0) {
#       paste("Covariates that support change:", paste(positive_vars, collapse = "\n"), sep = "\n")
#     } else {
#       NULL
#     },
#     if (length(negative_vars) > 0) {
#       paste("Covariates that do not support change:", paste(negative_vars, collapse = "\n"), sep = "\n")
#     } else {
#       NULL
#     },
#     sep = "\n\n"
#   )
# })
# 
# datatable(
#   clinicDomainTable %>% dplyr::select(
#     clinicSupport, clinicSupportRatio, AgreeRNAClinic,
#     all_of(classVariable), all_of(idColumn),
#     all_of(domainTableFeatures), PositiveColumns
#   ),
#   class = 'cell-border stripe',
#   options = list(
#     scrollX = TRUE,
#     columnDefs = list(
#       list(visible = FALSE, targets = "PositiveColumns")  # Ocultar la columna PositiveColumns
#     ),
#     rowCallback = JS(
#       "function(row, data) {
#         var positiveColumns = data[data.length - 1]; // Acceso a la última columna
#         $(row).on('click', function() {
#           if (positiveColumns) {
#             alert(positiveColumns);
#           }
#         });
#       }"
#     )
#   ),
#   escape = FALSE
# )
```


<!-- <!-- Modal Personalizado --> -->
<!-- <div id="customModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:50%; max-height:80%; padding:20px; background:white; border:1px solid #ccc; z-index:10000;"> -->
<!--   <div id="modalContent" style="max-height:60vh; overflow-y:auto;"></div> -->
<!--   <button onclick="$('#customModal').hide()">Cerrar</button> -->
<!-- </div> -->


```{r, echo = FALSE, warning = FALSE}
#tags$head(
#  tags$style(HTML("
#    #customModal {
#      display: none; /* Default to hidden */
#      position: fixed;
#      z-index: 1000;
#      left: 50%;
#      top: 50%;
#      transform: translate(-50%, -50%);
#      background-color: white;
#      border: 1px solid #ccc;
#      padding: 20px;
#      height: 400px; /* Set desired height */
#      overflow-y: auto; /* Add scrolling if content overflows */
#      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
#    }
    #modalContent {
#      max-height: calc(100% - 40px); /* Ensure content stays within modal */
#      overflow-y: auto;
#    }
#  "))
#)

```

```{r}
clinicDomainTable <- clinicDomainTable %>%
  mutate(diagnosis_type = ifelse(diagnosis_type == "Control2Case", "AHC", diagnosis_type))


```


```{r, echo = FALSE, warning = FALSE}
# Después de "clinicSupportRatio" tenía puesto "AgreeRNAClinic"
datatable(
  clinicDomainTable[26, ] %>% dplyr::select(
    clinicSupport, clinicSupportRatio,
    all_of(classVariable), all_of(idColumn),
    all_of(domainTableFeatures), PositiveColumns
  ),
  class = 'cell-border stripe',
  options = list(
    scrollX = TRUE,
    columnDefs = list(
      list(visible = FALSE, targets = "PositiveColumns")
    ),
    rowCallback = JS(
      "function(row, data) {
        var positiveColumns = data[data.length - 1];
        $(row).on('click', function() {
          if (positiveColumns) {
            $('#modalContent').html('<h3>Covariates Details</h3>' + positiveColumns);  // Set the content with HTML formatting
            $('#customModal').show();  // Display the modal
          }
        });
      }"
    )
  ),
  escape = FALSE
)


```

```{r}
# Carga de la librería DT
library(DT)

# Filtrar la fila 26 del dataframe
filtered_row <- clinicDomainTable[26, ]

# Excluir las columnas "AgreeRNAClinic" y "participant_id"
filtered_row <- filtered_row[, !(names(filtered_row) %in% c("AgreeRNAClinic", "participant_id"))]

# Seleccionar las primeras 10 columnas
filtered_row <- filtered_row[, 1:10]

# Redondear el valor de "B Cells Naive" a 3 decimales
filtered_row$b_cells_naive <- "0.087 +"


# Cambiar los nombres de las columnas
colnames(filtered_row) <- c(
  "Clinic Supports",
  "Clinic Supports Ratio",
  "Diagnosis",
  "Sex",
  "Ethnicity",
  "Race",
  "RIN Value",
  "Age At Baseline",
  "Mutation",
  "B Cells Naive"
)

# Cambiar los valores de "Diagnosis Type" de "Control2Case" a "AHC"
filtered_row$`Diagnosis`[filtered_row$`Diagnosis` == "Control2Case"] <- "AHC"

# Mostrar el datatable actualizado
datatable(filtered_row)




```

